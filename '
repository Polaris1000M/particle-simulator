#include "sphere.h"
#include <math.h>
#include <stdlib.h>
#include <cglm/cglm.h>

void sphereInit(Sphere* s, float radius, unsigned int sectors, unsigned int stacks) {
  s->radius = radius;
  s->sectors = sectors;
  s->stacks = stacks;
  s->n = 6 * sectors * stacks;
}

float* sphereVertices(Sphere* s) {
  float* vertices = malloc(sizeof(float) * s->n);

  float deltaSector = M_PI * 2.0f / (float) s->sectors;
  float deltaStack = M_PI / (float) s->stacks;

  for(unsigned int stack = 0; stack < s->stacks; stack++) {
    for(unsigned int sector = 0; sector < s->sectors; sector++) {
      float stackAngles[2];
      stackAngles[0] = M_PI / 2.0f - (float) stack * deltaStack;
      stackAngles[1] = stackAngles[0] - deltaStack;

      float sectorAngles[2];
      sectorAngles[0] = (float) sector * deltaSector;
      sectorAngles[1] = sectorAngles[0] + deltaSector;

      float x[4], y[4], z[4];
      for(unsigned int i = 0; i < 2; i++) {
        for(unsigned int j = 0; j < 2; j++) {
          int idx = i * 2 + j;
          x[idx] = s->radius * cos(stackAngles[i]) * sin(sectorAngles[j]);
          y[idx] = s->radius * sin(stackAngles[i]);
          z[idx] = s->radius * cos(stackAngles[i]) * cos(sectorAngles[j]);
        }
      }
      
      int idx = stack * s->sectors + sector * 6;
      for(int i = 0; i < 2; i++) {
        for(int j = 0; j < 3; j++) {
          vertices[idx + i + j] = x[i + j];
          vertices[idx + i + j + 1] = y[i + j];
          vertices[idx + i + j + 2] = z[i + j];
        }
      }
    }
  }

  return vertices;
}

void renderSphere(Simulation* sim, vec3 position, vec3 orientation, vec3 color, float radius) {
  Sphere s;
  sphereInit(&s, radius, 10, 10);

  float* vertices = sphereVertices(&s);
}
